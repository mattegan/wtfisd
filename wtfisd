#!/usr/local/bin/python3

#wtfisd - when the fuck is shit due (because simple)
#commands	
#	add:  accepts a time, date, title+details
#		date: accepts keywords (tomorrow, today, any day name within the next week)
#			  also accepts keyword for date "anytime" for get the shit done whenever
#			  also accepts slash-delimted dates mm/dd/yy or mm/dd, though zeros are not required
#		time: accepts single numbers 11 (assumes pm), or single numbers with am pm suffixes
#			  also accepts minutes, as 11:59 (assumes pm), or minutes with am pm suffixes (9:30pm)
#		title: a title for the shit, can contain spaces, anything you want (except a plus character)
#		details: included after the title directly after a plus character, as long as you want,
#				 newlines will be inserted automatically before the word in the details that pushes 
#				 the detail string over 60 characters
#	done: accepts a SID (shit identifier) to mark as done
#	jk: accepts a SID to mark as undone (if it's not already)
#	kill: accepts a SID to actually delete (not put in the done list) asks for confirmation
#	
#	if none of the previously listed commands are stated, wtfisd prints the things that are due in
#		with the most recent items first (even things past due)
#
#	flags to control list output (if flags are used, command list must be used)
#		-f  (feels) needs to be the first flag, lists only shit that you've completed
#		-s  (simple) don't list the SIDs next to each item
#		-d 	(date) list on a specific date, from earliest to latest in the day, accepts
#			a date keyword described above
#		-l  (limit) list only a specific count of the shit
#		-o 	(overdue) list only the shit you needed to get done but didn't
#
#	storage - flat files for lyfe (because simple)
#		- first line in the file is the SID incrementer
#		- each item is a line in a file, lines contain all the information about a piece of shit
#			- SID, completed, timestamp (unix bitches), title, details
#			- the SID is the first item of each line
#			- each item is followed by pluses (it's the evil character) in the order above
#	SID - generated by using some neat math shit
#		- the base 26 converstion of an integer (letters a-z, because ease)
#		- integer is seeded at a specific value
#		- each time an item is added, the integer is incremented by a specific value larger
#		  than one, this ensures that the SIDs are not close to one another, if the value
#		  after incrementing is larger than the number space, then it is looped around
#		  because modulus is fun
#

import sys, os
import shutil
from datetime import date, time, timedelta

#basic configuration
WTFISDFile = '/Users/matt/.shitlist'

#SID constants
SIDLength = 4										#how long is the SID
SIDCharacters = 'abcdefghijklmnopqrstuvwxyz'		#what characters are included in the SID
SIDIntegerIncrement = 5858							#controls magnitude of SID increment

#output styles, bitch

class styles:
	red = 			'\033[38;5;160m'
	blue =			'\033[38;5;33m'
	green =			'\033[38;5;28m'
	orange = 		'\033[38;5;166m'
	grey = 			'\033[38;5;232m'
	lightGrey = 	'\033[38;5;238m'
	underline = 	'\033[4m'
	bold = 			'\033[1m'
	reset = 		'\033[0m'

def style(text, styles, resetStyle):
	#returns a string that has had styles applied to it, ended with the reset style
	return ''.join(styles) + text + resetStyle

#handy methods

def convertBase10ToBaseN(x, baseString):
	#convert a base 10 number x into a base of len(baseString) using the characters defined
	#in baseString
	base = len(baseString)
	integerPart = int(x/base)
	remainder = int(base * (x/float(base) - integerPart))
	if integerPart == 0:
		return baseString[remainder]
	else:
		return convertBase10ToBaseN(integerPart, baseString) + baseString[remainder]

def error(errorDescription, tempFile):
	#print the error description, and quit execution
	print('error:' + errorDescription)
	os.remove(tempFile)
	quit()

def group(items, groupValue):
	grouped = {}
	ungrouped = list(range(0, len(items)))
	while len(ungrouped) > 0:
		matches = []
		candidate = items[ungrouped[0]]
		for index in ungrouped:
			if groupValue(items[index]) == groupValue(candidate):
				matches.append(index)
		for index in matches:
			del(ungrouped[ungrouped.index(index)])
		grouped[groupValue(candidate)] = [items[n] for n in matches]
	return grouped

def generatePrettyTime(string):
	#with a time string formatted hh:mm::ss, returns a seven character string containing the hours
	#and minutes in the original time and the am/pm suffix if the hour is singular, it returns the 
	#time padded by a space, as 05:00:00 will return ' 5:00am' and 17:00:00 will return ' 5:00pm'

	if string == '*':
		return string.rjust(7, ' ')

	components = list(map(lambda x: int(x), string.split(':')))
	suffix = 'am'
	if(components[0] > 12):
		components[0] = components[0] - 12
		suffix = 'pm'
	elif(components[0] == 0):
		components[0] = 12

	minutes = str(components[1]).rjust(2, '0')

	return str(components[0]).rjust(2) + ':' + minutes + suffix

def parseDateString(day):
	#accepts a python date object and returns either a list 'today', 'tomorrow', 'yesterday', or
	#the month of the day with a suffix (st, nd, th)
	if day == date.today():
		return [True, '=', 'today']
	elif day == date.today() + timedelta(days = 1):
		return [True, '+', 'tomorrow']
	elif day == date.today() - timedelta(days = 1):
		return [True, '-', 'yesterday']
	else:
		prefix = '-'
		suffix = ''
		if day > date.today():
			prefix = '+'
		if 4 <= day.day <= 20 or 24 <= day.day <= 30:
			suffix = 'th'
		else:
			suffix = ['st', 'nd', 'rd'][(day.day % 10) - 1]
		return [False, prefix, str(day.day), suffix, day.strftime(' %A').lower()]

def indentDescription(description, spaces, maxWidth):
	#accepts a description of any length and returns it with lines justified left, indentented by
	#spaces and with a maxWidth of width, doesn't deal with words longer than maxWidth characters
	words = description.split(' ')

	if len(words) == 1 and words[0] == '':
		return ''

	lines = []
	currentWord = 0
	currentLine = ''
	while currentWord < len(words):
		if len(currentLine) == 0:
			currentLine = currentLine + ''.rjust(spaces) + ' ' + words[currentWord]
			currentWord = currentWord + 1
		elif len(currentLine) + len(words[currentWord]) <= maxWidth:
			currentLine = currentLine + ' ' + words[currentWord]
			currentWord = currentWord + 1
		elif len(currentLine) + len(words[currentWord]) > maxWidth:
			lines.append(currentLine)
			currentLine = ''
	lines.append(currentLine)			
	return '\n'.join(lines) + '\n'
		

#SIDmethods

def generateSID(length, SIDInteger, characters):
	#generates a SID of width length, with the SID integer using only the specified characters
	SIDString = convertBase10ToBaseN(SIDInteger, characters)
	SIDString = SIDString.rjust(length, characters[0])
	return SIDString

def findLineWithSID(lines, SID):
	#find the index of the line that is reffered to by the SID
	for line in lines:
		if line[0] == SID: return lines.index(line)

	#if it wasn't found, the function hasn't returned yet, so return -1 to indicate an error
	return -1

def SIDFromArguments(arguments, SIDLength):
	#returns 0 if the length of arguments is not equal to one, if so, it ensures that the SID
	#provided in the arguments is equal to the required length, if not, returns 0, else, returns
	#the SID that was determined

	if len(arguments) != 1:
		return 0
	elif len(arguments[0]) != SIDLength:
		return 0
	else:
		return arguments[0]

#date methods

def parseDateDescriptor(string):
	#parses string, which should have no spaces, and can be in any of the following formats, returns
	#a python date object (for simple), which should just contain a day/month/year representation,
	#returns 0 if error (date out of range of month, unrecognized selector)
	#descriptor formats:
	#	one word descriptors: today, tomorrow, yesterday, anytime (special)
	#	any day of the week: monday, tuesday, wednesday, thursday, friday, saturday, sunday
	#		(note: these days are assumed to be during the upcoming week, not including today, if 
	#		today happens to be monday, and monday is supplied, the routine returns the monday a 
	#		week ahead)
	#	a month/day combination with no year: mm/dd, m/d, mm/d, m/dd (11/12, 1/5, 01/2, 1/25)
	#		(note: assumed to be current year)
	# 	a month/day/year combination: same as month/day with either a two or four character year
	#returns a string '*' if anytime is given
	
	if len(string.split(' ')) != 1:
		#the string should not contain any spaces
		return 0

	tokens = string.split('/')
	result = 0
	if len(tokens) == 1:
		today = date.today()
		weekday = today.weekday()
		#parse the string as a single keyword (day name, or keyword)
		possibilities = {	'today'		: today,
							'yesterday'	: today + timedelta(days=-1),
							'tomorrow'	: today + timedelta(days=1),
							'anytime'	: '*',
							'monday'	: 0,
							'tuesday'	: 1,
							'wednesday'	: 2,
							'thursday'	: 3,
							'friday'	: 4,
							'saturday'	: 5,
							'sunday'	: 6
						}
		if string in possibilities:
			#if the keyword is in the list of possibilities, do something with it
			result = possibilities[string]
			if result == weekday:
				#otherwise examine the weekday of the choice, if it's actually today, return 
				#today's weekday, but next week (there should be a way to include this in the math)
				result = today + timedelta(days = 7)
			elif type(result) == int:
				#otherwise, return the weekday sometime in advance
				result = today + timedelta(days = (7 + result - weekday) % 7)
	elif len(tokens) == 2:
		#parse the string as a month/day combination
		try:
			result = date(date.today().year, int(tokens[0]), int(tokens[1]))
		except:
			pass
	elif len(tokens) == 3:
		#parse the string as a month/day/year combination
		try:
			result = date(int(tokens[2]), int(tokens[0]), int(tokens[1]))
		except:
			pass
	return result

#time methods

def parseTimeDescriptor(string):
	#parses string, which should have no spaces, which is in one of the following formats, and
	#returns a python time object, or zero on error
	#descriptor formats
	#	keyword: noon, midnight, late, anytime
	#		noon = 12:00pm
	#		midnight = 12:00am
	#		late = 11:59pm
	#		anytime returns a '*'
	#	hour: hh, or h (examples 12, 01, 1)
	#	hour:minute: hh:mm, h:m, hh:m, h:mm (examples 02:34, 4:4, 12:4, 4:30)
	#	any previous format, with am/pm suffix: 3:34pm, 3:12pm, 01:40am, 3:40am, 11:59pm
	#(note: if am/pm suffix is not supplied, the function assumes pm)
	
	result = '';

	if len(string.split(' ')) != 1:
		#the string should not contain any spaces
		return 0

	possibilities = {	'noon'		: time(12),
						'midnight'	: time(0),
						'late'		: time(23, 59),
						'anytime'	: '*'
						}

	if string in possibilities:
		#test to see if a keyword was used
		result = possibilities[string]
	else:
		#try and determine if the time string has a suffix attached to it, if suppliment the hour
		#with 12 hours to fit it into the pm region of the 24 hour clock
		suffix = string[-2:]
		hourSuppliment = 12
		if suffix == 'am' or suffix == 'pm':
			#if there is a suffix, remove it from the date string
			string = string[:-2]
			if suffix == 'am': hourSuppliment = 0
			
		tokens = string.split(':')
		try:
			#attempt to convert the tokens into integers
			tokens = list(map(lambda n: int(n), tokens))

			if tokens[0] == 12 and hourSuppliment == 0:
				#detect the 12am conditions
				tokens[0] = 0
			elif tokens[0] == 12 and hourSuppliment == 12:
				#detect the 12pm conditions
				hourSuppliment = 0

			#otherwise, set the time using one or two tokens if they are supplied
			if len(tokens) == 1:
				result = time(tokens[0] + hourSuppliment)
			elif len(tokens) == 2:
				result = time(tokens[0] + hourSuppliment, tokens[1])
		except:
			#if anyting fucks up in there, there was an error, and return 0
			result = 0	
	return result


def generateTaskItemList(SIDInteger, SIDLength, SIDCharacters, arguments):
	#parses the list of arguments, returns 0 if it couldn't understand any of the supplied arguments
	#otherwise, it returns a list that contains the components of the task

	if len(arguments) < 3:
		#there needs to be at the very least, a date, time and title
		return 0

	#attempt to parse the date and time strings, if either fail, return 0
	time = parseTimeDescriptor(arguments[0]);
	date = parseDateDescriptor(arguments[1]);

	if time == 0 or date == 0:
		return 0

	#determine the title and description of the task
	title = ''
	description = ''

	titleComponents = arguments[2:]
	titleComponents = ' '.join(titleComponents).split('+')
	title = titleComponents[0]
	if len(titleComponents) == 2:
		description = titleComponents[1]

	#generate a SID
	SID = generateSID(SIDLength, SIDInteger, SIDCharacters)

	return [SID, 'i', str(time), str(date), title, description]

def changeStatus(status, arguments, lines, SIDLength):
	#accepts an argument and a list of tasks, modifies the correct line in the list with the updated
	#status identifier, and returns the correct list, returns 0 on error

	#determine the SID, if SID was not determined, return 0
	SID = SIDFromArguments(arguments, SIDLength)
	if SID == 0: return 0

	#if the SID wasn't found, return an error, if not, modify the status of the line to reflect
	#the status argument
	lineIndex = findLineWithSID(lines, SID)
	if lineIndex < 0:
		return 0
	else:
		lines[lineIndex][1] = status

	#returnm the lines
	return lines

def deleteTask(arguments, lines, SIDLength):
	#removes the task with an SID found in arguments (the first and only argument), and removes it
	#from the lines list, and returns the updated version of lines, if the SID was not found in 
	#lines, return 0

	#determine the SID, if SID was not determined, return 0
	SID = SIDFromArguments(arguments, SIDLength)
	if SID == 0: return 0

	lineIndex = findLineWithSID(lines, SID)
	if lineIndex < 0:
		return 0
	else:
		del(lines[lineIndex])

	return lines;

def listTasks(arguments, lines):
	tab = '    '
	today = str(date.today())
	overdue = 0
	days = group(lines, lambda n: n[3])
	for day in days:
		days[day] = group(days[day], lambda n: n[1])
		for status in days[day]:
			days[day][status].sort(key = lambda n: n[2])
		if day < today: overdue = overdue + len(days[day]['i'])

	#hold output until the end
	output = ''

	#output the amount of overdue items
	output = output + style('- ', [styles.bold, styles.red], styles.reset)
	output = output + style(str(overdue) + ' overdue', [styles.bold, styles.grey], styles.reset) + '\n'

	titleFormat = tab + '- ({0}) {1}'+ style(' - ', [styles.bold], styles.reset) + '{2}'

	#output the items due today

	day = today;
	for i in range(8):
		day = str(date.today() + timedelta(days = i))

		dayComponents = list(map(lambda n: int(n), day.split('-')))
		dateOutputItems = parseDateString(date(dayComponents[0], dayComponents[1], dayComponents[2]))
		prefixColor = styles.red
		if dateOutputItems[1] == '+':
			prefixColor = styles.green
		elif dateOutputItems[1] == '=':
			prefixColor = styles.orange
		output = output + style(dateOutputItems[1], [prefixColor, styles.bold], styles.reset) + ' '
		if dateOutputItems[0] == True:
			output = output + style(dateOutputItems[2], [styles.grey, styles.bold], styles.reset)
		else:
			output = output + style(dateOutputItems[2] + dateOutputItems[3], [styles.grey], styles.reset) + ''
			output = output + style(dateOutputItems[4], [styles.grey, styles.bold], styles.reset)

		output = output + '\n'

		SIDStyle = lambda t: style(t, [styles.lightGrey], styles.reset)
		timeStyle = lambda t: style(t, [styles.blue], styles.reset)
		titleStyle = lambda t: style(t, [styles.grey], styles.reset)
		descriptionStyle = lambda t: style(t, [styles.lightGrey], styles.reset)

		if day in days:
			if 'i' in days[day]:
	 			output = output + tab + style('incomplete', [styles.red], styles.reset) + '\n'
	 			for task in days[day]['i']:
		 			title = titleFormat.format(SIDStyle(task[0]), timeStyle(generatePrettyTime(task[2])), titleStyle(task[4]))
		 			output = output + title + '\n'
		 			output = output + descriptionStyle(indentDescription(task[5], 24, 80))
			if 'c' in days[day]:
				output = output + tab + style('complete', [styles.green], styles.reset) + '\n'
				for task in days[day]['c']:
					title = titleFormat.format(SIDStyle(task[0]), timeStyle(generatePrettyTime(task[2])), titleStyle(task[4]))
					output = output + title + '\n'
					output = output + descriptionStyle(indentDescription(task[5], 24, 80))
	print(output, end = '')

def main():

	
	#create a temporary file, so we don't fuck shit up accidentally
	temporaryWTFISDFile = WTFISDFile + '.tmp'
	shutil.copyfile(WTFISDFile, temporaryWTFISDFile);

	#attempt to open the file, and place all lines into lines variable, close the file
	f = open(temporaryWTFISDFile, mode = 'r', encoding = 'utf-8')
	lines = f.readlines()
	f.close()

	#the SID integer placement is always the first line of the file
	SIDInteger = int(lines[0])
	
	#remove the newline character from the end of each line, split into components
	lines = lines[1:]
	lines = list(map(lambda s: s.replace('\n', ''), lines))
	lines = list(map(lambda s: s.split('+'), lines))

	#ensure that each line has six items
	for line in lines:
		if len(line) < 6: error('corrupt list', temporaryWTFISDFile)

	#try to parse the arguments
	arguments = list(sys.argv[1:])
	command = ''
	
	if len(arguments) == 0:
		listTasks()
	else:
		command = arguments[0]
		arguments = arguments[1:]

	if command == 'add':
		#generate the task using the SID integer, ensure that nothing went fucking wrong, because
		#that'd just be a giant tragedy
		task = generateTaskItemList(SIDInteger, SIDLength, SIDCharacters, arguments)
		if task == 0: error('something is wrong', temporaryWTFISDFile)

		#increment the SID Integer
		SIDInteger = (SIDInteger + SIDIntegerIncrement) % pow(len(SIDCharacters), SIDLength)

		#add the task to the lines of the file
		lines.append(task)

	elif command == 'done':
		result = changeStatus('c', arguments, lines, SIDLength)
		if result == 0: quit('something is wrong', temporaryWTFISDFile)
	elif command == 'jk':
		result = changeStatus('i', arguments, lines, SIDLength)
		if result == 0: quit('something is wrong', temporaryWTFISDFile)
	elif command == 'kill':
		result = deleteTask(arguments, lines, SIDLength)
		if result == 0: quit('something is wrong', temporaryWTFISDFile)
	elif command == 'list':
		listTasks(arguments, lines)
	else:
		#print('\033[91m' + 'you' + '\033[0m')
		#print('\033[47m\033[1;31mBright red on white.\033[0m')
		#style([styles.red, styles.underline], styles.reset, 'hey there')
		error('unrecognized command', temporaryWTFISDFile)

	#complie the line strings back into their + delimited form, add the SIDInteger to the first line
	lineStrings = list(map(lambda s: '+'.join(s), lines))
	lineStrings.insert(0, str(SIDInteger))
	
	#after we've done what we've needed, write the SIDInteger and list to the temporary file
	f = open(temporaryWTFISDFile, mode = 'w', encoding = 'utf-8')
	f.write('\n'.join(lineStrings))
	f.close()

	#remove the original file, rename the temporary file to the original
	os.remove(WTFISDFile)
	os.rename(temporaryWTFISDFile, WTFISDFile)



if __name__ == '__main__':
	main()